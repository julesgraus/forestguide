/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/forestguide.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/AudioPlayer.js":
/*!*******************************!*\
  !*** ./src/js/AudioPlayer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _CallbackMapper = __webpack_require__(/*! ./CallbackMapper */ \"./src/js/CallbackMapper.js\");\n\nvar _CallbackMapper2 = _interopRequireDefault(_CallbackMapper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Knows how to play and work with audio.\r\n *\r\n * Note: Currently it is not possible to properly track the current play time correctly. Therefore we don't use the player for now.\r\n */\nvar AudioPlayer = function () {\n    function AudioPlayer() {\n        _classCallCheck(this, AudioPlayer);\n\n        this._callbackMapper = new _CallbackMapper2.default();\n        this._audio = null;\n        this._requestedPlay = false;\n        this._ignoreNextPauseForStop = false;\n        this._urlToLoad = null;\n        this._urlLoaded = false;\n    }\n\n    /**\r\n     * Attaches listeners to audio\r\n     *\r\n     * @private\r\n     */\n\n\n    _createClass(AudioPlayer, [{\n        key: '_enableListeners',\n        value: function _enableListeners() {\n            var enable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n            if (!this._audio) return null;\n\n            this._audio.removeEventListener('loadstart', this._loadStartHandler.bind(this));\n            this._audio.removeEventListener('durationchange', this._durationChangeHandler.bind(this));\n            this._audio.removeEventListener('loadedmetadata', this._loadedMetadataHandler.bind(this));\n            this._audio.removeEventListener('loadeddata', this._loadedDataHandler.bind(this));\n            this._audio.removeEventListener('progress', this._progressHandler.bind(this));\n            this._audio.removeEventListener('canplay', this._canPlayHandler.bind(this));\n            this._audio.removeEventListener('canplayTrough', this._canPlayTroughHandler.bind(this));\n            this._audio.removeEventListener('error', this._errorHandler.bind(this));\n            this._audio.removeEventListener('pause', this._pauseHandler.bind(this));\n            this._audio.removeEventListener('play', this._playHandler.bind(this));\n            this._audio.removeEventListener('timeupdate', this._timeUpdateHandler.bind(this));\n            this._audio.removeEventListener('ended', this._endedHandler.bind(this));\n\n            if (enable) {\n                this._audio.addEventListener('loadstart', this._loadStartHandler.bind(this));\n                this._audio.addEventListener('durationchange', this._durationChangeHandler.bind(this));\n                this._audio.addEventListener('loadedmetadata', this._loadedMetadataHandler.bind(this));\n                this._audio.addEventListener('loadeddata', this._loadedDataHandler.bind(this));\n                this._audio.addEventListener('progress', this._progressHandler.bind(this));\n                this._audio.addEventListener('canplay', this._canPlayHandler.bind(this));\n                this._audio.addEventListener('canplayTrough', this._canPlayTroughHandler.bind(this));\n                this._audio.addEventListener('error', this._errorHandler.bind(this));\n                this._audio.addEventListener('pause', this._pauseHandler.bind(this));\n                this._audio.addEventListener('play', this._playHandler.bind(this));\n                this._audio.addEventListener('timeupdate', this._timeUpdateHandler.bind(this));\n                this._audio.addEventListener('ended', this._endedHandler.bind(this));\n            }\n        }\n\n        /**\r\n         * Event handler for when loading of the audio begins.\r\n         *\r\n         * @param {ProgressEvent} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_loadStartHandler',\n        value: function _loadStartHandler(event) {\n            if (!this._audio) return null;\n            this._callbackMapper.trigger('loading');\n        }\n\n        /**\r\n         * Event handler for when the metadata has loaded or changed, indicating a change in duration of the media.\r\n         * This is sent, for example, when the media has loaded enough that the duration is known.\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_durationChangeHandler',\n        value: function _durationChangeHandler(event) {\n            if (!this._audio) return null;\n        }\n\n        /**\r\n         * Event handler for when when the metadata has been loaded.\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_loadedMetadataHandler',\n        value: function _loadedMetadataHandler(event) {\n            if (!this._audio) return null;\n        }\n\n        /**\r\n         * Event handler for when the first frame of the media has finished loading.\r\n         * Note that this event will not fire in mobile/tablet devices if data-saver is on in browser settings.\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_loadedDataHandler',\n        value: function _loadedDataHandler(event) {\n            if (!this._audio) return null;\n        }\n\n        /**\r\n         * Event handler for when event is fired to indicate that an operation is in progress.\r\n         * Sent periodically to inform interested parties of progress downloading the media.\r\n         * Information about the current amount of the media that has been downloaded is available in\r\n         * the media element's (this._audio) buffered attribute.\r\n         *\r\n         * @param {ProgressEvent} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_progressHandler',\n        value: function _progressHandler(event) {\n            if (!this._audio) return null;\n        }\n\n        /**\r\n         * Event handler for when enough data is available that the media can be played,\r\n         * at least for a couple of frames. This corresponds to the HAVE_ENOUGH_DATA readyState\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_canPlayHandler',\n        value: function _canPlayHandler(event) {\n            if (!this._audio) return null;\n            if (this._requestedPlay === true) {\n                this._requestedPlay = false;\n                this._audio.play();\n                this._callbackMapper.trigger('play');\n            }\n            this._urlLoaded = true;\n            this._callbackMapper.trigger('canPlay');\n        }\n\n        /**\r\n         * Event handler for when the ready state changes to CAN_PLAY_THROUGH,\r\n         * indicating that the entire media can be played without interruption,\r\n         * assuming the download rate remains at least at the current level.\r\n         * It will also be fired when playback is toggled between paused and playing.\r\n         * Note: Manually setting the currentTime will eventually fire a canplaythrough event in firefox.\r\n         * Other browsers might not fire this event.\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_canPlayTroughHandler',\n        value: function _canPlayTroughHandler(event) {\n            if (!this._audio) return null;\n        }\n\n        /**\r\n         * Event handler for when an error occurs.  The element's error attribute contains more information\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_errorHandler',\n        value: function _errorHandler(event) {\n            if (!this._audio) return null;\n            console.error('AudioPlayer:error An error occured: ', this._audio.error);\n        }\n\n        /**\r\n         * Event handler for when the playback state is no longer paused,\r\n         * as a result of the play method, or the autoplay attribute.\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_playHandler',\n        value: function _playHandler(event) {\n            if (!this._audio) return null;\n            this._callbackMapper.trigger('play');\n        }\n\n        /**\r\n         * Event handler for when the playback state is changed to paused (paused property is true).\r\n         *\r\n         * @param {Event} event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_pauseHandler',\n        value: function _pauseHandler(event) {\n            if (!this._audio) return null;\n            if (this._ignoreNextPauseForStop) {\n                this._ignoreNextPauseForStop = false;\n                return;\n            } //A stop was triggered. That's a pause followed by setDuration = 0. We ignore this pause in such situations\n            this._callbackMapper.trigger('pause');\n        }\n\n        /**\r\n         * When the time indicated by the currentTime attribute has been updated.\r\n         *\r\n         * @param event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_timeUpdateHandler',\n        value: function _timeUpdateHandler(event) {\n            if (!this._audio || !this.isPlaying()) return null;\n            this._callbackMapper.trigger('playProgress');\n        }\n\n        /**\r\n         * Event handler for when the media has finished playing\r\n         *\r\n         * @param event\r\n         * @private\r\n         */\n\n    }, {\n        key: '_endedHandler',\n        value: function _endedHandler(event) {\n            if (!this._audio) return null;\n            this._callbackMapper.trigger('finish');\n        }\n\n        /**\r\n         * Triggered when loading has started\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onLoading',\n        value: function onLoading(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('loading', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has loaded enough to trigger playing\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onCanPlay',\n        value: function onCanPlay(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('canPlay', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has begun playing\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onPlay',\n        value: function onPlay(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('play', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has been paused\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onPause',\n        value: function onPause(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('pause', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has been stopped\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onStopped',\n        value: function onStopped(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('stop', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has progressed in play duration\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onPlayProgress',\n        value: function onPlayProgress(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('playProgress', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Triggered when the audio has finished playing\r\n         *\r\n         * @param callback\r\n         * @param args\r\n         * @return AudioPlayer\r\n         */\n\n    }, {\n        key: 'onFinish',\n        value: function onFinish(callback) {\n            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            this._callbackMapper.on('finish', callback, args);\n            return this;\n        }\n\n        /**\r\n         * Clear system resources\r\n         *\r\n         * @private\r\n         */\n\n    }, {\n        key: '_reset',\n        value: function _reset() {\n            if (!this._audio) return null;\n            this.stop();\n            this._enableListeners(false);\n            this._audio = null;\n        }\n\n        /**\r\n         * Stops playback\r\n         *\r\n         * @return {null}\r\n         */\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            if (!this._audio) return null;\n            this._ignoreNextPauseForStop = true; //Prevent pause event from being processed\n            this._audio.pause();\n            this._audio.currentTime = 0;\n            this._callbackMapper.trigger('stop');\n        }\n\n        /**\r\n         * @param {string} soundUrl\r\n         *\r\n         * Returns a Promise that resolves with the player instance. Or rejects with an error message\r\n         */\n\n    }, {\n        key: 'load',\n        value: function load(soundUrl) {\n            if (this._urlToLoad === soundUrl && this._urlLoaded === true) {\n                // console.log('Warning: Already loaded '+soundUrl+'. Not loading again.');\n                return;\n            } //We already loaded the url.\n            this._urlToLoad = soundUrl;\n\n            if (typeof soundUrl !== \"string\") {\n                console.error('Player: Could not play the sound because the url wasn\\'t a string.');\n                return;\n            }\n\n            this._reset();\n            this._audio = new Audio(soundUrl);\n            this._enableListeners();\n        }\n\n        /**\r\n         * Requests to play the sound as soon as it is loaded\r\n         */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            if (!this._audio) return null;\n            this._requestedPlay = true;\n            if (this._urlLoaded) this._canPlayHandler(null); //Because the url is loaded it won't trigger the _canPlayHandler. So we do it manually. The handler will play the sound.\n        }\n\n        /**\r\n         * Pause the audio\r\n         *\r\n         * @return {null}\r\n         */\n\n    }, {\n        key: 'pause',\n        value: function pause() {\n            if (!this._audio) return null;\n            this._audio.pause();\n        }\n\n        /**\r\n         * Sets the current time in seconds from where to play from\r\n         *\r\n         * @param {number} time\r\n         */\n\n    }, {\n        key: 'setCurrentTime',\n        value: function setCurrentTime(time) {\n            if (!this._audio) return null;\n            if (typeof time !== \"number\") {\n                console.error('AudioPlayer:setCurrentTime Did not receive a number. It must be the number of seconds you want to play from');\n            }\n        }\n\n        /**\r\n         * Gets the current time in seconds from where to play from\r\n         *\r\n         * @return {number}\r\n         */\n\n    }, {\n        key: 'getCurrentTime',\n        value: function getCurrentTime() {\n            if (!this._audio) return 0;\n            return this._audio.currentTime;\n        }\n\n        /**\r\n         * Detect whether or not audio is playing or not\r\n         *\r\n         * @return {boolean}\r\n         */\n\n    }, {\n        key: 'isPlaying',\n        value: function isPlaying() {\n            return !!(this._audio && this._audio.currentTime > 0 && !this._audio.paused && !this._audio.ended && this._audio.readyState > 2);\n        }\n    }]);\n\n    return AudioPlayer;\n}();\n\nexports.default = AudioPlayer;\n\n//# sourceURL=webpack:///./src/js/AudioPlayer.js?");

/***/ }),

/***/ "./src/js/CallbackMapper.js":
/*!**********************************!*\
  !*** ./src/js/CallbackMapper.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Registers actions and can map those to callbacks.\r\n *\r\n * It provides methods to trigger actions that trigger callbacks.\r\n * It also provides methods to register those callbacks\r\n */\nvar CalbackMapper = function () {\n    /**\r\n     * CallbackMapper constructor\r\n     */\n    function CalbackMapper() {\n        _classCallCheck(this, CalbackMapper);\n\n        this._callbackMap = {};\n        this._argsMap = {};\n    }\n\n    /**\r\n     * Registers a callback to an action that you can trigger with the trigger method.\r\n     * You can also pass in\r\n     *\r\n     * @param  {string} action\r\n     * @param {function} callback\r\n     * @param {array} args\r\n     */\n\n\n    _createClass(CalbackMapper, [{\n        key: \"on\",\n        value: function on(action, callback) {\n            var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n            if (typeof action !== \"string\") {\n                console.error('CallbackMapper: not registering callback since the action is not a string');\n                return;\n            }\n            if (typeof callback !== \"function\") {\n                console.error('CallbackMapper: not registering callback since the callback is not a function');\n                return;\n            }\n            if (!Array.isArray(args)) {\n                console.error('CallbackMapper: not registering callback since the args parameter is not an array');\n                return;\n            }\n            if (!this._callbackMap.hasOwnProperty(action)) this._callbackMap[action] = [];\n            if (!this._argsMap.hasOwnProperty(action)) this._argsMap[action] = [];\n\n            this._callbackMap[action].push(callback);\n            this._argsMap[action].push(args);\n        }\n\n        /**\r\n         * @param {string} action\r\n         */\n\n    }, {\n        key: \"trigger\",\n        value: function trigger(action) {\n            if (typeof action !== \"string\") {\n                console.error('CallbackMapper: not triggering callback since the action is not a string');\n                return;\n            }\n\n            if (!this._callbackMap.hasOwnProperty(action) && !this._argsMap.hasOwnProperty(action)) {\n                return;\n            }\n\n            var callbacksCount = this._callbackMap[action].length;\n            for (var index = 0; index < callbacksCount; index++) {\n                this._callbackMap[action][index].apply(this, this._argsMap[action][index]);\n            }\n        }\n    }]);\n\n    return CalbackMapper;\n}();\n\nexports.default = CalbackMapper;\n\n//# sourceURL=webpack:///./src/js/CallbackMapper.js?");

/***/ }),

/***/ "./src/js/DataRetriever.js":
/*!*********************************!*\
  !*** ./src/js/DataRetriever.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Does know how to retrieve data using get requests.\r\n *\r\n * It's like a rest client, but does not have all the features.\r\n */\nvar DataRetriever = function () {\n    function DataRetriever() {\n        _classCallCheck(this, DataRetriever);\n\n        //Initialize vars\n        this._headers = {};\n        this._request = null;\n        this._username = null;\n        this._password = null;\n        this._responseType = 'text';\n    }\n\n    /**\r\n     * Intializes a connection\r\n     *\r\n     * @private\r\n     * @return DataRetriever\r\n     */\n\n\n    _createClass(DataRetriever, [{\n        key: '_init',\n        value: function _init() {\n            this._request = new XMLHttpRequest();\n            return this;\n        }\n\n        /**\r\n         * Opens the connection and sets the request headers.\r\n         *\r\n         * @param method\r\n         * @param url\r\n         * @private\r\n         *\r\n         * @see setHeader\r\n         */\n\n    }, {\n        key: '_open',\n        value: function _open(method, url) {\n            if (typeof method !== \"string\") {\n                console.error('DataRetriever:_open The method must be a string');\n                return;\n            }\n\n            if (typeof url !== \"string\") {\n                console.error('DataRetriever:_open The url must be a string');\n                return;\n            }\n\n            this._request.open(method.toUpperCase(), url, true, self._username, self._password);\n            for (var headerName in self._headers) {\n                if (!self._headers.hasOwnProperty(headerName)) continue;\n                this._request.setRequestHeader(headerName, self._headers[headerName]);\n            }\n\n            this._request.responseType = this._responseType;\n        }\n\n        /**\r\n         * Send the request to the server\r\n         *\r\n         * @private\r\n         */\n\n    }, {\n        key: '_send',\n        value: function _send(successCallback, failureCallback) {\n            var self = this;\n\n            this._request.onreadystatechange = function () {\n                switch (self._request.readyState) {\n                    case XMLHttpRequest.UNSENT:\n                        break;\n                    case XMLHttpRequest.OPENED:\n                        break;\n                    case XMLHttpRequest.HEADERS_RECEIVED:\n                        break;\n                    case XMLHttpRequest.LOADING:\n                        break;\n                    case XMLHttpRequest.DONE:\n                        switch (self._request.status) {\n                            case 200:\n                                successCallback.call(self, self._request.response);\n                                break;\n                            default:\n                                failureCallback.call(self, self._request.statusText);\n                                break;\n                        }\n                        break;\n                }\n            };\n            this._request.send();\n        }\n\n        /**\r\n         * Set the expected response type\r\n         */\n\n    }, {\n        key: 'setResponseType',\n        value: function setResponseType() {\n            var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'text';\n\n            var supportedTypes = ['text', 'arraybuffer', 'blob', 'document'];\n\n            if (typeof type !== \"string\" || supportedTypes.indexOf(type) === -1) {\n                console.log('Dataretriever:setResponseType: The type was not valid. It must be one of these: ' + supportedTypes.join(', '));\n            }\n            this._responseType = type;\n        }\n\n        /**\r\n         * Removes all headers you've set with setHeader\r\n         *\r\n         * @return DataRetriever\r\n         */\n\n    }, {\n        key: 'clearHeaders',\n        value: function clearHeaders() {\n            this._headers = {};\n        }\n\n        /**\r\n         * Sets / overrides a header for the next request\r\n         *\r\n         * @param headerName\r\n         * @param headerValues\r\n         * @return DataRetriever\r\n         */\n\n    }, {\n        key: 'setHeader',\n        value: function setHeader(headerName, headerValues) {\n            this._headers[headerName] = headerValues;\n            return this;\n        }\n\n        /**\r\n         * Sets the username for when performing a request\r\n         *\r\n         * @param value\r\n         */\n\n    }, {\n        key: 'get',\n\n\n        /**\r\n         * Perform a HTTP Get request.\r\n         * Returns a promise that either resolves to a response. Or rejects with a status text\r\n         *\r\n         * @param {string} url\r\n         * @return {Promise}\r\n         */\n        value: function get(url) {\n            var self = this;\n\n            if (typeof url !== \"string\") {\n                console.error('DataRetriever:get The url must be a string');\n                return Promise.reject('DataRetriever:get The url must be a string'); //Return a rejected promise\n            }\n\n            return new Promise(function (resolve, reject) {\n                self._init();\n                self._open(\"GET\", url);\n                self._send(resolve, reject);\n            });\n        }\n    }, {\n        key: 'username',\n        set: function set(value) {\n            if (typeof value !== \"string\") {\n                console.error('DataRetriever:setUsername The username must be a string');\n                return;\n            }\n            this._username = value;\n        }\n\n        /**\r\n         * Sets a password for when performing a request\r\n         *\r\n         * @param value\r\n         */\n\n    }, {\n        key: 'password',\n        set: function set(value) {\n            if (typeof value !== \"string\") {\n                console.error('DataRetriever:setPassword The password must be a string');\n                return;\n            }\n            this._password = value;\n        }\n    }]);\n\n    return DataRetriever;\n}();\n\nexports.default = DataRetriever;\n\n//# sourceURL=webpack:///./src/js/DataRetriever.js?");

/***/ }),

/***/ "./src/js/forestguide.js":
/*!*******************************!*\
  !*** ./src/js/forestguide.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _AudioPlayer = __webpack_require__(/*! ./AudioPlayer */ \"./src/js/AudioPlayer.js\");\n\nvar _AudioPlayer2 = _interopRequireDefault(_AudioPlayer);\n\nvar _Config = __webpack_require__(/*! ./models/Config */ \"./src/js/models/Config.js\");\n\nvar _Config2 = _interopRequireDefault(_Config);\n\nvar _DataRetriever = __webpack_require__(/*! ./DataRetriever */ \"./src/js/DataRetriever.js\");\n\nvar _DataRetriever2 = _interopRequireDefault(_DataRetriever);\n\nvar _Guide = __webpack_require__(/*! ./models/Guide */ \"./src/js/models/Guide.js\");\n\nvar _Guide2 = _interopRequireDefault(_Guide);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * @class ForestGuide. Guides users through your app.\r\n */\nvar ForestGuide = function () {\n    /**\r\n     * The forest guide constructor\r\n     *\r\n     * @param {object} config\r\n     */\n    function ForestGuide(config) {\n        _classCallCheck(this, ForestGuide);\n\n        //Initialize dependencies\n        this._dataRetriever = new _DataRetriever2.default();\n        this._config = new _Config2.default(config);\n        this._audioPlayer = new _AudioPlayer2.default();\n\n        //initialize scalar variables\n        this._guideDataAttributeName = 'forest-guide';\n        this._camelCasedGuideDataAttributeName = 'forestGuide';\n\n        //Initialize html elements\n        this._guideButtons = null;\n\n        //Further initialize the class by delegating to other methods\n        this._initializeGuideButtons();\n    }\n\n    /**\r\n     * Scans the document for elements which match the guideButtonSelector.\r\n     * And links them to this class so that when they are clicked the appropriate guide will\r\n     * be loaded, by using the attributes value.\r\n     *\r\n     * @private\r\n     */\n\n\n    _createClass(ForestGuide, [{\n        key: '_initializeGuideButtons',\n        value: function _initializeGuideButtons() {\n            var self = this;\n            var selector = \"[data-\" + this._guideDataAttributeName + \"]\";\n            this._guideButtons = document.querySelectorAll(selector);\n\n            this._guideButtons.forEach(function (guideButton) {\n                guideButton.addEventListener('click', self._guideButtonClicked.bind(self));\n            });\n        }\n\n        /**\r\n         * Triggered when a guide button is clicked\r\n         *\r\n         * @param {MouseEvent} mouseEvent\r\n         * @private\r\n         */\n\n    }, {\n        key: '_guideButtonClicked',\n        value: function _guideButtonClicked(mouseEvent) {\n            var self = this;\n            var button = mouseEvent.target;\n            mouseEvent.preventDefault();\n            if (!this._guideDataAttributeName in button.dataset) {\n                console.error('Could process a click on a ForestGuide guide button since it did not contain the data attribute \"data-' + this._guideDataAttributeName + '\" anymore.');\n            }\n\n            var guideName = button.dataset[this._camelCasedGuideDataAttributeName];\n\n            this._dataRetriever.get(this._config.rootUrl + guideName + '.json').then(function (response) {\n                var json = {};\n                try {\n                    json = JSON.parse(response);\n                } catch (e) {\n                    console.error('ForestGuide: The json as denoted in the guide \"' + guideName + '\" was invalid. ' + e.message);\n                    return;\n                }\n\n                var guideModel = _Guide2.default.fromJson(json);\n                self._startOrStopGuidance(guideModel, button);\n            }).catch(function (reason) {\n                console.error('ForestGuide: Could not retrieve guide \"' + guideName + '\" because of an error: ' + reason);\n            });\n        }\n\n        /**\r\n         * @param {Guide} guide\r\n         * @param button The guide button that was clicked and eventually triggered this method\r\n         * @private\r\n         */\n\n    }, {\n        key: '_startOrStopGuidance',\n        value: function _startOrStopGuidance(guide, button) {\n            var self = this;\n            if (this._audioPlayer.isPlaying() === false) {\n                this._audioPlayer.onLoading(function () {\n                    button.classList.add(self._config.loadingClass);\n                    button.classList.remove(self._config.playingClass);\n                }).onPlay(function () {\n                    button.classList.remove(self._config.loadingClass);\n                    button.classList.add(self._config.playingClass);\n                }).onPause(function () {\n                    button.classList.remove(self._config.loadingClass);\n                    button.classList.remove(self._config.playingClass);\n                }).onPlayProgress(function () {}).onFinish(function () {\n                    button.classList.remove(self._config.loadingClass);\n                    button.classList.remove(self._config.playingClass);\n                }).onStopped(function () {\n                    button.classList.remove(self._config.loadingClass);\n                    button.classList.remove(self._config.playingClass);\n                });\n                this._audioPlayer.load(this._config.rootUrl + guide.soundFile);\n                this._audioPlayer.play();\n            } else {\n                this._audioPlayer.stop();\n                this._audioPlayer = new _AudioPlayer2.default();\n            }\n        }\n    }]);\n\n    return ForestGuide;\n}();\n\n//Link forest guide to the window object (global namespace) so that other scripts can utilize it.\n\n\nexports.default = ForestGuide;\nwindow.ForestGuide = ForestGuide;\n\n//# sourceURL=webpack:///./src/js/forestguide.js?");

/***/ }),

/***/ "./src/js/models/Action.js":
/*!*********************************!*\
  !*** ./src/js/models/Action.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Defines Action data that belongs to a Cue\r\n *\r\n * @see Cue\r\n */\nvar Action = function () {\n    function Action() {\n        _classCallCheck(this, Action);\n\n        this._name = '';\n        this._options = {};\n    }\n\n    /**\r\n     * Create a new instance from a json object\r\n     *\r\n     * @param object\r\n     */\n\n\n    _createClass(Action, [{\n        key: \"name\",\n\n\n        /**\r\n         * @return {string}\r\n         */\n        get: function get() {\n            return this._name;\n        }\n\n        /**\r\n         * @return {{}}\r\n         */\n\n    }, {\n        key: \"options\",\n        get: function get() {\n            return this._options;\n        }\n    }], [{\n        key: \"fromJson\",\n        value: function fromJson(object) {\n            var trueOrError = Action.validate(object);\n            if (trueOrError !== true) {\n                console.error(trueOrError);\n                return null;\n            }\n\n            var instance = new Action();\n            instance._name = object.name;\n            instance._options = object.options;\n            return instance;\n        }\n\n        /**\r\n         * Returns true if the object has valid action data. And a string containing errors if not valid.\r\n         *\r\n         * @param object\r\n         */\n\n    }, {\n        key: \"validate\",\n        value: function validate(object) {\n            if (typeof object === \"undefined\") return \"Action: The action is not valid because it was undefined\";\n            if (!object.hasOwnProperty('name') || typeof object.name !== \"string\") return \"Action: The action was not valid. It must contain a string property called name\";\n            if (!object.hasOwnProperty('options') || _typeof(object.options) !== \"object\") return \"Action: The action was not valid. It must contain an object property called options\";\n\n            return true;\n        }\n    }]);\n\n    return Action;\n}();\n\nexports.default = Action;\n\n//# sourceURL=webpack:///./src/js/models/Action.js?");

/***/ }),

/***/ "./src/js/models/Config.js":
/*!*********************************!*\
  !*** ./src/js/models/Config.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * The config object holds configuration data for ForestGuide itself.\r\n * It does not contain guidance data.\r\n */\nvar Config = function () {\n    function Config(configObject) {\n        _classCallCheck(this, Config);\n\n        if (typeof configObject === 'undefined') configObject = {};\n\n        this._rootUrl = configObject.hasOwnProperty('rootUrl') && typeof configObject.rootUrl === \"string\" ? configObject.rootUrl : 'forestguide/';\n        if (this._rootUrl.substr(this.rootUrl.length - 1) !== '/') this._rootUrl += '/';\n        this._loadingClass = configObject.hasOwnProperty('loadingClass') && typeof configObject.loadingClass === \"string\" ? configObject.loadingClass : 'loading';\n        this._playingClass = configObject.hasOwnProperty('playingClass') && typeof configObject.playingClass === \"string\" ? configObject.playingClass : 'playing';\n    }\n\n    /**\r\n     * The url where all ForestGuide data can be retrieved from\r\n     *\r\n     * @returns {string}\r\n     */\n\n\n    _createClass(Config, [{\n        key: 'rootUrl',\n        get: function get() {\n            return this._rootUrl;\n        }\n\n        /**\r\n         * The class to add to buttons when data is loading\r\n         *\r\n         * @return {string|*}\r\n         */\n\n    }, {\n        key: 'loadingClass',\n        get: function get() {\n            return this._loadingClass;\n        }\n\n        /**\r\n         * The class to add to buttons when they are playing\r\n         *\r\n         * @return {string|*}\r\n         */\n\n    }, {\n        key: 'playingClass',\n        get: function get() {\n            return this._playingClass;\n        }\n    }]);\n\n    return Config;\n}();\n\nexports.default = Config;\n\n//# sourceURL=webpack:///./src/js/models/Config.js?");

/***/ }),

/***/ "./src/js/models/Cue.js":
/*!******************************!*\
  !*** ./src/js/models/Cue.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Action = __webpack_require__(/*! ./Action */ \"./src/js/models/Action.js\");\n\nvar _Action2 = _interopRequireDefault(_Action);\n\nvar _Guide = __webpack_require__(/*! ./Guide */ \"./src/js/models/Guide.js\");\n\nvar _Guide2 = _interopRequireDefault(_Guide);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Defines Cue data that belongs to a Guide\r\n *\r\n * @see Guide\r\n */\nvar Cue = function () {\n    function Cue() {\n        _classCallCheck(this, Cue);\n\n        this._start = 0;\n        this._end = 0;\n        this._selector = '';\n        this._actions = [];\n    }\n\n    /**\r\n     * Create a new instance from a json object\r\n     *\r\n     * @param object\r\n     */\n\n\n    _createClass(Cue, [{\n        key: \"start\",\n\n\n        /**\r\n         * @return {number}\r\n         */\n        get: function get() {\n            return this._start;\n        }\n\n        /**\r\n         * @return {number}\r\n         */\n\n    }, {\n        key: \"end\",\n        get: function get() {\n            return this._end;\n        }\n\n        /**\r\n         * @return {string}\r\n         */\n\n    }, {\n        key: \"selector\",\n        get: function get() {\n            return this._selector;\n        }\n\n        /**\r\n         * @return {Action[]}\r\n         */\n\n    }, {\n        key: \"actions\",\n        get: function get() {\n            return this._actions;\n        }\n    }], [{\n        key: \"fromJson\",\n        value: function fromJson(object) {\n            var trueOrError = Cue.validate(object);\n            if (trueOrError !== true) {\n                console.error(trueOrError);\n                return null;\n            }\n\n            var instance = new Cue();\n            instance._start = object.start;\n            instance._end = object.end;\n            instance._selector = object.selector;\n            instance._actions = object.actions;\n            return instance;\n        }\n\n        /**\r\n         * Returns true if the object has valid cue data. And a string containing errors if not valid.\r\n         *\r\n         * @param object\r\n         */\n\n    }, {\n        key: \"validate\",\n        value: function validate(object) {\n            if (typeof object === \"undefined\") return \"Cue: The cue is not valid because it was undefined\";\n            if (!object.hasOwnProperty('start') || typeof object.start !== \"number\") return \"Cue: The cue was not valid. It must contain a number property called start\";\n            if (!object.hasOwnProperty('end') || typeof object.end !== \"number\") return \"Cue: The cue was not valid. It must contain a number property called end\";\n            if (!object.hasOwnProperty('selector') || typeof object.selector !== \"string\") return \"Cue: The cue was not valid. It must contain a string property called selector\";\n\n            if (!object.hasOwnProperty('actions') || !Array.isArray(object.actions)) return \"Cue: The cue was not valid. It must contain an array property called actions\";\n\n            var actionCount = object.actions.length;\n            for (var index = 0; index < actionCount; index++) {\n                var action = object.actions[index];\n                var trueOrError = _Action2.default.validate(action);\n                if (trueOrError !== true) return trueOrError;\n            }\n\n            return true;\n        }\n    }]);\n\n    return Cue;\n}();\n\nexports.default = Cue;\n\n//# sourceURL=webpack:///./src/js/models/Cue.js?");

/***/ }),

/***/ "./src/js/models/Guide.js":
/*!********************************!*\
  !*** ./src/js/models/Guide.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Cue = __webpack_require__(/*! ./Cue */ \"./src/js/models/Cue.js\");\n\nvar _Cue2 = _interopRequireDefault(_Cue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Defines Guide data.\r\n */\nvar Guide = function () {\n    function Guide() {\n        _classCallCheck(this, Guide);\n\n        this._soundFile = '';\n        this._cues = [];\n    }\n\n    /**\r\n     * Create a new instance from a json object\r\n     *\r\n     * @param object\r\n     * @return {null|Guide}\r\n     */\n\n\n    _createClass(Guide, [{\n        key: \"soundFile\",\n\n\n        /**\r\n         * @return {string}\r\n         */\n        get: function get() {\n            return this._soundFile;\n        }\n\n        /**\r\n         * @return {Cue[]}\r\n         */\n\n    }, {\n        key: \"cues\",\n        get: function get() {\n            return this._cues;\n        }\n    }], [{\n        key: \"fromJson\",\n        value: function fromJson(object) {\n            var trueOrError = Guide.validate(object);\n            if (trueOrError !== true) {\n                console.error(trueOrError);\n                return null;\n            }\n\n            var instance = new Guide();\n            instance._soundFile = object.soundFile;\n            instance._cues = object.cues;\n            return instance;\n        }\n\n        /**\r\n         * Returns true if the given object is a valid Guide. Or a string containing errors if not valid\r\n         *\r\n         * @param object\r\n         * @return {boolean|string}\r\n         */\n\n    }, {\n        key: \"validate\",\n        value: function validate(object) {\n            if (typeof object === \"undefined\") return \"Guide: The guide is not valid because it was undefined\";\n            if (!object.hasOwnProperty(\"soundFile\") || typeof object.soundFile !== \"string\") return \"Guide: The guide is not valid. It must have a string property called soundFile.\";\n            if (!object.hasOwnProperty(\"cues\") || !Array.isArray(object.cues)) return \"Guide: The guide is not valid. It must have an array property called 'cues'\";\n\n            var cueCount = object.cues.length;\n            for (var index = 0; index < cueCount; index++) {\n                var cue = object.cues[index];\n                var trueOrError = _Cue2.default.validate(cue);\n                if (trueOrError !== true) return trueOrError;\n            }\n\n            return true;\n        }\n    }]);\n\n    return Guide;\n}();\n\nexports.default = Guide;\n\n//# sourceURL=webpack:///./src/js/models/Guide.js?");

/***/ })

/******/ });